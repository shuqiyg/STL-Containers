After finishing workshop 6, I’ve learned how to use the vector container to manage polymorphic objects, append a dynamically allocated object into a container, utilize the range-based iteration on the objects inside a container and properly handle exceptions. In our application, both Cars and Racecars are concrete classes inherited from abstract class Vehicle. Autoshop class is designed to manage any polymorphic object that’s created dynamically, its data member std::vector<Vehicle*> m_vehicles serves as a container, and operator += is overloaded to add a Vehicle type object.

In Autoshop Module, there are 2 cases that we use STL iterators. One is in void Autoshop::display(std::ostream& out) when we output every Vehicle object, and the other is in Autoshop::~Autoshop() when we deallocate every dynamically allocated Vehicle object. In Module Utilities, an exception is thrown if an unrecognized type of car is encounter, and it will be caught when function createInstance(std::istream&) is called in w6_p2.cpp.

Vector stores values without regard for what those values represent, therefore it doesn’t know it’s supposed to delete the values when it’s destroyed, if we don’t deallocate the dynamically allocated memory(free the resources), there will be a guarantee memory leak. For loadData() function to detect any invalid data, we can use a switch statement to filter and catch any error before loading the data into other functions or constructors. Instead of storing pointers of vehicles we can also store vehicles objects in a vector, but those objects will be copies instead of direct references of the originals.
